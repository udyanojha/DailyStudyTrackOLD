# DailyStudyTrack
This is to keep track of the topics studied or revised 


## <li>21/August/22
 ### DEV <br>
 --> JS splice(), loops

 ### DSA <br>
 --> Fenwick Tree <br>

## <li>18/August/22 - 20/August/22 
 ### Joined Coding Ninja as a TA and doing DEV <br>

## <li>16/August/22
 ### DSA<Br>
 --> TicTacToe <br>


## <li>15/August/22 (ION GROUP - RJECTED)


## <li>10/August/22
 ### DSA<Br>
 --> Graph - 3 Cycle <br>
 --> Revision - Print Paths <br>
 --> Connected components <br>
 --> Number Of Islands <br>
 --> Largest Piece <br>


## <li>09/August/22
 ### DSA<Br>
 --> Graph - Island (Components)<br>
 --> CODINGNINJAS String Graph DFS<br>


## <li>08/August/22 (Atlassian Test - Boii long way to go REJECTED)
 ### DSA<Br>
 --> Dijkstra Adj. Matrix Done <br> 



## <li>07/August/22
 ### DSA<Br>
 --> Dijkstra Algorithm started<br>



## <li>05/August/22
 ### DSA<Br>
 --> Kruskal's Algorithm<br>
 --> Prims's Algorithm Started<br>

## <li>04/August/22
 ### DSA<Br>
 --> Kruskal's Algorithm<br>

## <li>02/August/22
 ### DSA<Br>
 --> Graph Cyclic Detection<br>


## <li>01/August/22
 ### DSA<Br>
 --> Code : Get Path - DFS <br>
 --> Code : Get Path - BFS <br>
 --> Code : Is Connected ? <br>
 --> Code : All connected components <br>
 

## <li>31/July/22
 ### DSA<Br>
 --> Maximum Square Matrix With All Zeros <br> 
 --> Smallest Super-Sequence <br>
 --> Graph Started <br>
 --> Graph Implementation <br>
 --> Adjacency Matrix vs Adjacency List <br>
 --> Code : BFS Traversal <br>
 --> Code : Has Path <br>



## <li>30/July/22
 ### DSA<Br>
 --> Coin Tower <br> 
 


## <li>29/July/22
 ### DSA<Br>
 --> Trie Palindrom Pair <br>
 --> Trie Auto Complete <br>
 --> Loot Houses <br>
 

## <li>27/July/22
 ### DSA<Br>
 --> Code: Knapsack(Memoization and DP) <br>


## <li>26/July/22
 ### DSA<Br>
 --> LCS <br>
 --> Code: Edit Distance <br>
 --> Code: Edit Distance(Memoization and DP) <br>
 --> Code: 0 1 Knapsack <br>
 


## <li>25/July/22
 ### DSA<Br>
 --> Priority Queue & DP Continued <br>
 --> Code: Number of Balanced BTs Completed <br>
 --> Code: Minimum Count of Squares REVISIT <br>
 --> DP : PEP - Coin Change Permutations <br>
 --> DP : PEP - Coin Change Combination <br>
 --> Amazon Test <br>
 --> Byte Landian DP <br>
 --> Code : Minimum Cost Path <br>


## <li>24/July/22
 ### DSA<Br>
 --> Priority Queue Continued <br>
 --> Code - Implace Heap sort done <br>
 --> K Largest element AL<br>
 --> K smallest Element AL<br>
 --> Check Max-Heap <br>
 --> Kth largest element <br>
 --> Trie Started<br>
 --> Trie Implementation <br>
 --> Trie Vs HashMap <br>
 --> Count Words in Trie <br>
 --> Buy the ticket <br>
 --> Pattern Matching <br>
 --> Running Median <br>
 --> Merge K sorted arrays <br>
 --> some Trie pending <br>
 --> DP - Code: Min Steps to One <br>
 --> Code: Staircase <br>
 --> Code: Number of Balanced BTs pending...<br>


## <li>23/July/22 (Amazon OA for BIE & DE REJECTED)
 ### DSA<Br>
--> DP Start PriorityQueue pending <br>
--> Fibonacci DP <br>

 ### CORE CS <br>
 --> Computer Networks Basics <br>
 --> Linux Started <br>

## <li>22/July/22
 ### SQL<Br>
 --> Basics Done<br>
 --> Leetcode SQL: easy 3 Qs


## <li>21/July/22
 ### DSA<Br>
 --> PriorityQueue Continue<br>
 --> Code - Implace Heap sort Pending <br>
 ### SQL <br>
 --> Basics of SQL <br>


## <li>20/July/22
 ### DSA<Br>
 --> Priority Queue Continue <br>
 --> Code : Remove Min <br>
 --> Code : Max Priority Queue <br>
 

## <li>19/July/22
 ### DSA<Br>
 --> Priority Queue & Heap theory <br>
 --> Priority Queue Implementation <br>
 --> LeetCode :
      - Middle Of A LinkedList <br>
      - Reverse a LinkedList<br>
      - Reorder a LinkedLIst<br>
      - Merge Two Sorted LinkedList <br>
      - Merge K sorted Linked list <br>


## <li>19/July/22
 ### DSA<Br>
 --> HashMap Continue<br>
 --> Print Intersection<br>
 --> Extract Unique characters<br>
 --> Longest Consecutive Sequence<br>
 --> Pairs with difference K<br>
 --> Longest subset zero sum<br>
 --> LeetCode : 3. Longest Substring Without Repeating Characters <br>
 --> LeetCode : 217. Contains Duplicate <br>
 --> LeetCode : 242. Valid Anagram <br>


## <li>18/July/22
 ### DSA<Br>
 --> Leetcode: addTwoNumbers LinkedList <br>
 --> HashMap Theory <br>
 --> Priority Queue <br>


## <li>17/July/22
 ### DSA<Br>
 --> Binary Search Tree continue<br>
 --> Path Sum Root to Leaf *DO AGAIN* for O(log n) space<br>
 --> Print nodes at distance k from node <br>
 --> Pair sum in a BST <br>
 --> Check cousins DO AGAIN <br>
 --> Longest Leaf to root path<br>
 --> Remove leaf nodes in Tree<br>
 --> HashMap Start <br>
 --> Maximum Frequency Number <br>
 --> Pair Sum to 0 <br>
 --> 


## <li>16/July/22
 ### DSA<Br>
 --> Binary Search Tree continue<br>
 --> Largest BST<br>
 --> Replace with Sum of greater nodes Do dry run<br>

 ### SQL<br>
 --> basics <br> 
 
## <li>15/July/22
 ### DSA<Br>
 --> Binary Search Tree continue<br>
 --> Find path in BST <br>
 --> Create & Insert Duplicate Node <br>
 --> LCA of Binary Tree <br>
 --> LCA of BST <br>
 --> Pair Sum Binary Tree <br>
 --> Path Sum Root to Leaf <br>


## <li>14/July/22
 ### DSA<Br>
 --> Binary Search Tree continue<br>
 --> Print nodes at distance k from node PENDING <br>
 --> Check if a Binary Tree is BST 3 methods used 1st have to do other 2<br> 
 --> Code: Construct BST From Sorted Array <br>
 --> Code: BST to Sorted LL NOT EFFICIENT pending class method<br>


## <li>13/July/22
 ### DSA<Br>
 --> Binary Tree continue<br>
 --> Diameter Of Binary Tree Using class <br>
 --> Mirror a Binary Tree <br>
 --> Preorder Binary Tree <br>
 --> Postorder Binary Tree<br>
 --> Code: Search Node in BST <br>
 --> Code: Print Elements in Range <br>
 --> Code: Construct Tree from Preorder and Inorder <br>
 --> Code: Construct Tree from Postorder and Inorder <br>
 --> Create & Insert Duplicate Node to left <br>
 --> Minimum and Maximum in the Binary Tree <br>
 --> Level order traversal in BT <br>
 --> Path Sum Root to Leaf <br>
 
### DEV <br>
--> Added contact us to HTML CSS RESUME page<br>
--> Making work experience section pending <br>


## <li>12/July/22
 ### DSA<Br>
 --> Tree and Binary Tree continue<br>
 --> Sum of nodes <br>
 --> find node <br>
 --> print levelwise <br>
 --> Nodes Greater Than X <br>
 --> Height Of Binary Tree <br>
 --> Replace Node With Depth <br>
 --> Nodes without sibling <br>
 --> Diameter Of Binary Tree O(n^2)<br>


## <li>10/July/22
 ### DSA<Br>
 --> Tree continue<br>
 --> Node having sum of children and node is max using Class<br>
 --> Structurally identical using Queue Pending Recursion<br>
 --> Next larger element using Queue and Stack Pending Recursion <br>
 --> Second Largest Element In Tree <br>
 --> Replace node with depth <br>
 
 ### Open Source <br>
 --> Got PR merged at PublicLabs<br>


## <li>09/July/22
 ### Google Cloud Labs<Br>

## <li>08/July/22
 ### Google Cloud Labs<Br>

## <li>07/July/22
 ### Google Cloud Labs<Br>

## <li>06/July/22
 ### Google Cloud Labs<Br>


## <li>05/July/22
 ### DSA<Br>
 --> Tree<br>
 --> Tree implementation using ArrayList <br>
 --> Tree takeInput() recursively <br>
 --> print() recursively <br>
 --> print() levelwise using Queue<br>
 --> takeInput() levelwise using Queue<br>
 --> Count total nodes in a tree<br>
 --> Height of the tree <br>
 --> Depth theory can be done using k as argument in recursion<br>
 --> Count Leaf nodes<br>
 --> Traversals - LevelWise (Queue using breakNode)<br>
 --> Traversals - preOrder<br>
 --> Traversals - postOrder<br>
 --> Number of nodes greater than x<br>

 
## <li>04/July/22
 ### Google Cloud Labs<Br>


## <li>03/July/22<br>

## <li>02/July/22
 ### DSA<Br>
 --> Target Sum Subarray<br>
 --> N-Queens<br>
 --> K-Knights<br>
 --> Redundant Brackets Stack <br>
 --> Balanced Brackets Stack <br>
 --> Next Greater Element To The Right<br>


## <li>01/July/22
 ### DSA<Br>
 --> Revising Recursion<br>
 --> Get Maze Path<br>
 --> Get Maze Path with Jumps<br>
 --> Print Subsequence<br>
 --> print kpc<br>
 --> print stair path<br>
 --> print maze path and with jump <br>
 --> print permutations<br>
 --> Print Encodings '0' case <br>
 --> Flood Fill using -1 as visited<br>
 --> Flood Fill using Visited Boolean to back track <br> 
 --> LeetCode 1710. Maximum Units on a Truck using recursion<br>


## <li>30/June/22
 ### DSA<Br>
 --> Stack using 2 Queue<br>
 --> Reverse Queue recursively<br>
 --> Reverse the First K Elements in the Queue O(n^2) & O(n)<br>
 --> Double Ended Queue Using LinkedList TODO using array<br>
 --> Next Number (increment a num in LL e.g. 9 -> 9 -> 9 to 1->0->0->0) <br> 
 --> Delete Alternate Nodes LL easy <br>

 ### <li>WEBDEV<br>
 --> Started building Resume WebPage<br>
 --> Added navbar, Header Section, About Section <br>


## <li>29/June/22
 ### DSA<Br>
 --> Minimum bracket Reversal (revisit)<br>
 --> Queue -- Implementation using Array<br>
 --> Queue -- Implementation usind Linked List <br>

 ### <li>WEBDEV<br>
 --> Flex<br>


## <li>28/June/22<br>
 

## <li>27/June/22
 ### DSA<Br>
 --> Stock Span using hint<br>


## <li>26/June/22
 ### DSA<Br>
 --> kReverse Recursively DoubleNode class<br>
 --> Bubble Sort on LL Iteratively. (PRACTISE) <br>
 --> We can solve it recursively refer to row col pattern approach<br>
 --> Stack -- Implementation using array Exceptions<br>
 --> Stack -- Implementation using Singly Linked List O(1) Pop and Push<br>
 --> Balanced Parenthesis <br>
 --> Check redundant brackets <br>
 --> Stock Span (continue)... <br>


 ### <li>WEBDEV<br>
 --> Display inline, block, inline-block<br>
 --> Margin <br>
 --> Padding<br>
 --> Basic Blog edits <br>
 --> Position Ficed need top argument <br>


## <li>25/June/22
 ### DSA<Br>
 --> Even after Odd LinkedList O(N) space O(N)<br>
 --> Revision of LL<br>
 --> Delete every N nodes <br>
 --> Swap two Nodes of LL <br>
 --> kReverse trying pending...<br>
 
 ### <li>WEBDEV<br>
 --> Form<br>
 --> Reported a bug to security team while exploring the website <br>
 --> Made Login and Registeration form using sandbox <br>
 --> Basics of CSS<br>
 
 ### <li>Extra<br>
 --> Google Cloud Labs <br>


## <li>24/June/22
 ### DSA<Br>
  --> Palindrome LinkedList (done) find mid point, can be done using slow fast point approach.<br> then reversed the LL and compared till head2 not null <br>
  --> Code : Midpoint of Linked list (return mid node)<br>
  --> Merge two sorted LinkedList O(1) Space <br>
  --> MergeSort in LinkedList<br>
  --> Deleting a node (recursively)<br>
  --> Reverse LL (Recursive) O(n^2) O(n) by doubleNode and by storing next node as tail <br>
  --> Circular Singly LL <br>
  --> Circular Doubly LL <br>
  --> LinkedList Collection framework<br>
  <br>
 ### WEBDEV<br>
  --> Basics of HTML<br>
  --> Schedule Table (rowspan colspan) <br>
 

## <li>23/June/22
### OOPs<br>
--> Learned OOPs concepts like abstract classes -- need to be implemented in subclass unless specified abstract <br>
--> Interface -- contains all abstract methods <br>
--> Generic Classes ArrayList<T> T representing generic <br>
<br>
### DSA<br>
-->  Started with LinkedList <br>
--> Implementation of LL self by creating Generic Node class<br>
  --> Basic methods insert delete find ith<br>
  --> Find a node in LinkedList <Br>
  --> Append last N to First<br>
  --> Eliminate Duplicates from LinkedList<br>
  --> Print Reversed Linked List<br>
  --> Palindrome LinkedList -- (?) pending...

  
  
  
